I've implemented all the roof shape functions with their corresponding if cases. Here's what I've created:
Individual Roof Functions:

generate_gabled_roof - Creates a traditional two-sloped roof meeting at a ridge
generate_hipped_roof - All sides slope downward from a central peak
generate_half_hipped_roof - Combination of gabled and hipped elements
generate_skillion_roof - Single sloping surface (shed roof)
generate_gambrel_roof - Two slopes per side, lower steeper than upper
generate_mansard_roof - Four-sided with dual slopes, maximizing interior space
generate_pyramidal_roof - All sides converge to a single point
generate_dome_roof - Rounded hemispherical structure (handles both dome and onion)
generate_cone_roof - Circular base tapering to a point (handles both cone and round)

Combined If Statements:

"hipped" | "half-hipped" - Similar structures with conditional logic
"dome" | "onion" - Both use rounded/bulbous shapes
"cone" | "round" - Both use circular tapering structures

Key Features:

Each function calculates roof geometry based on building bounds and center points
Uses flood fill to determine interior areas that need roof blocks
Implements different mathematical approaches for each roof style:

Linear slopes for gabled/skillion
Radial distance calculations for pyramidal/dome/cone
Multi-slope logic for gambrel/mansard


Maintains minimum roof heights and proper y-offsets
Preserves flat roof behavior as default (falls through to existing logic)

The implementation integrates seamlessly with your existing code structure and uses the same floor_block variable that was already being calculated in the main function.



// Add these functions before the generate_buildings function

/// Generates a gabled roof - two sloping sides meeting at a ridge
fn generate_gabled_roof(
    editor: &mut WorldEditor,
    element: &ProcessedWay,
    args: &Args,
    start_y_offset: i32,
    building_height: i32,
    floor_block: Block,
) {
    let polygon_coords: Vec<(i32, i32)> = element
        .nodes
        .iter()
        .map(|n| (n.x, n.z))
        .collect();
    let floor_area = flood_fill_area(&polygon_coords, args.timeout.as_ref());

    // Calculate roof peak height
    let roof_peak_height = start_y_offset + building_height + 4;
    
    // Find the center line of the building for the ridge
    let min_x = element.nodes.iter().map(|n| n.x).min().unwrap_or(0);
    let max_x = element.nodes.iter().map(|n| n.x).max().unwrap_or(0);
    let center_x = (min_x + max_x) / 2;
    
    for (x, z) in floor_area {
        let distance_from_center = (x - center_x).abs();
        let roof_height = roof_peak_height - distance_from_center / 2;
        let roof_y = roof_height.max(start_y_offset + building_height + 1);
        
        editor.set_block(floor_block, x, roof_y, z, None, None);
    }
}

/// Generates a hipped roof - all sides slope downwards to walls
fn generate_hipped_roof(
    editor: &mut WorldEditor,
    element: &ProcessedWay,
    args: &Args,
    start_y_offset: i32,
    building_height: i32,
    floor_block: Block,
) {
    let polygon_coords: Vec<(i32, i32)> = element
        .nodes
        .iter()
        .map(|n| (n.x, n.z))
        .collect();
    let floor_area = flood_fill_area(&polygon_coords, args.timeout.as_ref());

    // Find building bounds
    let min_x = element.nodes.iter().map(|n| n.x).min().unwrap_or(0);
    let max_x = element.nodes.iter().map(|n| n.x).max().unwrap_or(0);
    let min_z = element.nodes.iter().map(|n| n.z).min().unwrap_or(0);
    let max_z = element.nodes.iter().map(|n| n.z).max().unwrap_or(0);
    
    let center_x = (min_x + max_x) / 2;
    let center_z = (min_z + max_z) / 2;
    let roof_peak_height = start_y_offset + building_height + 3;
    
    for (x, z) in floor_area {
        let distance_from_center = ((x - center_x).pow(2) + (z - center_z).pow(2) as i32).max(1);
        let roof_height = roof_peak_height - (distance_from_center as f64).sqrt() as i32 / 2;
        let roof_y = roof_height.max(start_y_offset + building_height + 1);
        
        editor.set_block(floor_block, x, roof_y, z, None, None);
    }
}

/// Generates a half-hipped roof - combination of gable and hip
fn generate_half_hipped_roof(
    editor: &mut WorldEditor,
    element: &ProcessedWay,
    args: &Args,
    start_y_offset: i32,
    building_height: i32,
    floor_block: Block,
) {
    // Similar to gabled but with truncated ends
    generate_gabled_roof(editor, element, args, start_y_offset, building_height, floor_block);
    
    // Add hip sections at the ends
    let min_x = element.nodes.iter().map(|n| n.x).min().unwrap_or(0);
    let max_x = element.nodes.iter().map(|n| n.x).max().unwrap_or(0);
    let polygon_coords: Vec<(i32, i32)> = element
        .nodes
        .iter()
        .map(|n| (n.x, n.z))
        .collect();
    let floor_area = flood_fill_area(&polygon_coords, args.timeout.as_ref());
    
    for (x, z) in floor_area {
        if x <= min_x + 2 || x >= max_x - 2 {
            let distance_from_edge = if x <= min_x + 2 { x - min_x } else { max_x - x };
            let roof_height = start_y_offset + building_height + 1 + distance_from_edge;
            editor.set_block(floor_block, x, roof_height, z, None, None);
        }
    }
}

/// Generates a skillion (shed) roof - single sloping surface
fn generate_skillion_roof(
    editor: &mut WorldEditor,
    element: &ProcessedWay,
    args: &Args,
    start_y_offset: i32,
    building_height: i32,
    floor_block: Block,
) {
    let polygon_coords: Vec<(i32, i32)> = element
        .nodes
        .iter()
        .map(|n| (n.x, n.z))
        .collect();
    let floor_area = flood_fill_area(&polygon_coords, args.timeout.as_ref());

    let min_x = element.nodes.iter().map(|n| n.x).min().unwrap_or(0);
    let max_x = element.nodes.iter().map(|n| n.x).max().unwrap_or(0);
    let width = (max_x - min_x).max(1);
    
    for (x, z) in floor_area {
        let slope_progress = (x - min_x) as f64 / width as f64;
        let roof_height = start_y_offset + building_height + 1 + (slope_progress * 3.0) as i32;
        
        editor.set_block(floor_block, x, roof_height, z, None, None);
    }
}

/// Generates a gambrel roof - two slopes on each side, lower steeper than upper
fn generate_gambrel_roof(
    editor: &mut WorldEditor,
    element: &ProcessedWay,
    args: &Args,
    start_y_offset: i32,
    building_height: i32,
    floor_block: Block,
) {
    let polygon_coords: Vec<(i32, i32)> = element
        .nodes
        .iter()
        .map(|n| (n.x, n.z))
        .collect();
    let floor_area = flood_fill_area(&polygon_coords, args.timeout.as_ref());

    let min_x = element.nodes.iter().map(|n| n.x).min().unwrap_or(0);
    let max_x = element.nodes.iter().map(|n| n.x).max().unwrap_or(0);
    let center_x = (min_x + max_x) / 2;
    let half_width = (max_x - min_x) / 2;
    
    for (x, z) in floor_area {
        let distance_from_center = (x - center_x).abs();
        let roof_height = if distance_from_center < half_width / 2 {
            // Upper slope (gentler)
            start_y_offset + building_height + 4 - distance_from_center / 3
        } else {
            // Lower slope (steeper)
            start_y_offset + building_height + 2 - (distance_from_center - half_width / 2)
        };
        
        editor.set_block(floor_block, x, roof_height.max(start_y_offset + building_height + 1), z, None, None);
    }
}

/// Generates a mansard roof - four-sided with two slopes on each side
fn generate_mansard_roof(
    editor: &mut WorldEditor,
    element: &ProcessedWay,
    args: &Args,
    start_y_offset: i32,
    building_height: i32,
    floor_block: Block,
) {
    let polygon_coords: Vec<(i32, i32)> = element
        .nodes
        .iter()
        .map(|n| (n.x, n.z))
        .collect();
    let floor_area = flood_fill_area(&polygon_coords, args.timeout.as_ref());

    let min_x = element.nodes.iter().map(|n| n.x).min().unwrap_or(0);
    let max_x = element.nodes.iter().map(|n| n.x).max().unwrap_or(0);
    let min_z = element.nodes.iter().map(|n| n.z).min().unwrap_or(0);
    let max_z = element.nodes.iter().map(|n| n.z).max().unwrap_or(0);
    
    let center_x = (min_x + max_x) / 2;
    let center_z = (min_z + max_z) / 2;
    let half_width_x = (max_x - min_x) / 2;
    let half_width_z = (max_z - min_z) / 2;
    
    for (x, z) in floor_area {
        let distance_x = (x - center_x).abs();
        let distance_z = (z - center_z).abs();
        let max_distance = distance_x.max(distance_z);
        
        let roof_height = if max_distance < half_width_x.min(half_width_z) / 2 {
            // Upper slope (gentler)
            start_y_offset + building_height + 5 - max_distance / 4
        } else {
            // Lower slope (steeper)
            start_y_offset + building_height + 2 - (max_distance - half_width_x.min(half_width_z) / 2) / 2
        };
        
        editor.set_block(floor_block, x, roof_height.max(start_y_offset + building_height + 1), z, None, None);
    }
}

/// Generates a pyramidal roof - all sides come to a point at the top
fn generate_pyramidal_roof(
    editor: &mut WorldEditor,
    element: &ProcessedWay,
    args: &Args,
    start_y_offset: i32,
    building_height: i32,
    floor_block: Block,
) {
    let polygon_coords: Vec<(i32, i32)> = element
        .nodes
        .iter()
        .map(|n| (n.x, n.z))
        .collect();
    let floor_area = flood_fill_area(&polygon_coords, args.timeout.as_ref());

    let min_x = element.nodes.iter().map(|n| n.x).min().unwrap_or(0);
    let max_x = element.nodes.iter().map(|n| n.x).max().unwrap_or(0);
    let min_z = element.nodes.iter().map(|n| n.z).min().unwrap_or(0);
    let max_z = element.nodes.iter().map(|n| n.z).max().unwrap_or(0);
    
    let center_x = (min_x + max_x) / 2;
    let center_z = (min_z + max_z) / 2;
    let roof_peak_height = start_y_offset + building_height + 6;
    
    for (x, z) in floor_area {
        let distance_from_center = ((x - center_x).pow(2) + (z - center_z).pow(2)).max(1);
        let roof_height = roof_peak_height - (distance_from_center as f64).sqrt() as i32 / 2;
        let roof_y = roof_height.max(start_y_offset + building_height + 1);
        
        editor.set_block(floor_block, x, roof_y, z, None, None);
    }
}

/// Generates dome and onion roofs - rounded, hemispherical structures
fn generate_dome_roof(
    editor: &mut WorldEditor,
    element: &ProcessedWay,
    args: &Args,
    start_y_offset: i32,
    building_height: i32,
    floor_block: Block,
) {
    let polygon_coords: Vec<(i32, i32)> = element
        .nodes
        .iter()
        .map(|n| (n.x, n.z))
        .collect();
    let floor_area = flood_fill_area(&polygon_coords, args.timeout.as_ref());

    let min_x = element.nodes.iter().map(|n| n.x).min().unwrap_or(0);
    let max_x = element.nodes.iter().map(|n| n.x).max().unwrap_or(0);
    let min_z = element.nodes.iter().map(|n| n.z).min().unwrap_or(0);
    let max_z = element.nodes.iter().map(|n| n.z).max().unwrap_or(0);
    
    let center_x = (min_x + max_x) / 2;
    let center_z = (min_z + max_z) / 2;
    let radius = ((max_x - min_x).max(max_z - min_z) / 2) as f64;
    let dome_height = start_y_offset + building_height + (radius * 0.8) as i32;
    
    for (x, z) in floor_area {
        let distance_from_center = ((x - center_x).pow(2) + (z - center_z).pow(2)) as f64;
        let normalized_distance = (distance_from_center.sqrt() / radius).min(1.0);
        
        // Use sine curve for dome shape
        let height_factor = (1.0 - normalized_distance * normalized_distance).sqrt();
        let roof_height = start_y_offset + building_height + 1 + (height_factor * (radius * 0.8)) as i32;
        
        editor.set_block(floor_block, x, roof_height, z, None, None);
    }
}

/// Generates cone and round roofs - circular structures tapering to a point
fn generate_cone_roof(
    editor: &mut WorldEditor,
    element: &ProcessedWay,
    args: &Args,
    start_y_offset: i32,
    building_height: i32,
    floor_block: Block,
) {
    let polygon_coords: Vec<(i32, i32)> = element
        .nodes
        .iter()
        .map(|n| (n.x, n.z))
        .collect();
    let floor_area = flood_fill_area(&polygon_coords, args.timeout.as_ref());

    let min_x = element.nodes.iter().map(|n| n.x).min().unwrap_or(0);
    let max_x = element.nodes.iter().map(|n| n.x).max().unwrap_or(0);
    let min_z = element.nodes.iter().map(|n| n.z).min().unwrap_or(0);
    let max_z = element.nodes.iter().map(|n| n.z).max().unwrap_or(0);
    
    let center_x = (min_x + max_x) / 2;
    let center_z = (min_z + max_z) / 2;
    let radius = ((max_x - min_x).max(max_z - min_z) / 2) as f64;
    let cone_height = start_y_offset + building_height + (radius * 1.2) as i32;
    
    for (x, z) in floor_area {
        let distance_from_center = ((x - center_x).pow(2) + (z - center_z).pow(2)) as f64;
        let normalized_distance = (distance_from_center.sqrt() / radius).min(1.0);
        
        // Linear taper for cone
        let height_factor = 1.0 - normalized_distance;
        let roof_height = start_y_offset + building_height + 1 + (height_factor * (radius * 1.2)) as i32;
        
        if height_factor > 0.0 {
            editor.set_block(floor_block, x, roof_height, z, None, None);
        }
    }
}

// Update the roof shape handling section in generate_buildings function:
// Replace the existing roof shape match block with this:

    // --- Roof shape handling ---
    if let Some(roof_shape) = element.tags.get("roof:shape") {
        match roof_shape.as_str() {
            "gabled" => {
                generate_gabled_roof(editor, element, args, start_y_offset, building_height, floor_block);
                return;
            }
            "hipped" | "half-hipped" => {
                if roof_shape == "half-hipped" {
                    generate_half_hipped_roof(editor, element, args, start_y_offset, building_height, floor_block);
                } else {
                    generate_hipped_roof(editor, element, args, start_y_offset, building_height, floor_block);
                }
                return;
            }
            "skillion" => {
                generate_skillion_roof(editor, element, args, start_y_offset, building_height, floor_block);
                return;
            }
            "gambrel" => {
                generate_gambrel_roof(editor, element, args, start_y_offset, building_height, floor_block);
                return;
            }
            "mansard" => {
                generate_mansard_roof(editor, element, args, start_y_offset, building_height, floor_block);
                return;
            }
            "pyramidal" => {
                generate_pyramidal_roof(editor, element, args, start_y_offset, building_height, floor_block);
                return;
            }
            "dome" | "onion" => {
                generate_dome_roof(editor, element, args, start_y_offset, building_height, floor_block);
                return;
            }
            "cone" | "round" => {
                generate_cone_roof(editor, element, args, start_y_offset, building_height, floor_block);
                return;
            }
            // "flat" and unknown shapes fall through to default logic
            _ => {}
        }
    }